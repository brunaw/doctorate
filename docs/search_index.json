[
["index.html", "Quebrando CAPTCHAs Capítulo 1 Introduction", " Quebrando CAPTCHAs Julio Trecenti 09 de julho de 2018 Capítulo 1 Introduction "],
["introducao.html", "Capítulo 2 Introdução 2.1 Objetivos 2.2 Resultados Esperados 2.3 Organização do trabalho", " Capítulo 2 Introdução 2.1 Objetivos 2.2 Resultados Esperados 2.3 Organização do trabalho "],
["problema.html", "Capítulo 3 Problema 3.1 Variantes", " Capítulo 3 Problema O problema do Captcha pode ser entendido como um problema de classificação de imagens. Especificamente, nosso interesse é criar uma função \\(g\\) que recebe uma imagem \\(\\mathbf X = \\{x_{nmr} \\in [0,1]\\}_{N\\times M \\times R}\\) e retorna um vetor de índices \\(\\mathbf y\\), sendo que cada índice \\(y_j\\) corresponde a um caractere \\(c_j\\), \\(j = 1, \\dots, L\\), onde \\(L\\) é o número de caracteres contidos na imagem. Das afirmações anteriores podemos tirar três conclusões. Nossa variável explicativa, a imagem, é uma matriz \\(\\mathbf X = \\{x_{ijk}\\}_{N\\times M \\times R}\\), em que \\(N\\) é o número de linhas, \\(M\\) é o número de colunas e \\(R\\) é o número de cores, ou canais. O elemento \\(x_{nm\\cdot}\\) é denominado pixel. Um pixel representa a menor unidade possível da imagem. Em uma imagem colorida, por exemplo, temos \\(R=3\\). Nesse caso, um pixel é um vetor de três dimensões com valores entre zero e um, representando a intensidade de vermelho, verde e azul da coordenada \\(n,m\\) da imagem. Numa imagem em escala de cinza, temos \\(R=1\\) e o pixel, de uma dimensão, representa a intensidade do cinza (com 1=branco e 0=preto). O objeto \\(C \\in \\mathcal A^L\\) é um vetor de itens de um alfabeto \\(\\mathcal A\\) com tamanho \\(|\\mathcal A|\\), finito e conhecido. Esse alfabeto contém todos os possíveis caracteres que podem aparecer na imagem. Nossa resposta \\(\\mathbf y \\in \\mathbb \\{1, \\dots, |\\mathcal A|\\}^L\\) é um vetor de índices de tamanho fixo. Cada elemento de \\(\\mathbf y\\) representa um valor do alfabeto \\(\\mathcal A\\). A construção de uma função \\(g\\) capaz de mapear \\(\\mathbf y\\) a partir de uma nova imagem \\(\\mathbf X\\) depende de uma amostra de imagens \\(\\mathbf X_1, \\dots, \\mathbf X_S\\) corretamente classificadas por \\(\\mathbf y_1, \\dots, \\mathbf y_S\\). A tarefa é, portanto, estimar uma função \\(\\hat g\\) com o objetivo de minimizar. \\[ L(g(\\mathbf X), \\mathbf y) = \\mathbb I(g(\\mathbf X) \\neq \\mathbf y) \\] em que \\(\\mathbb I\\) é a função indicadora. 3.1 Variantes 3.1.1 Áudio Captchas também podem se manifestar na forma de áudio. Nesses casos, o usuário é condicionado a ouvir um áudio e transcrever seu conteúdo em um texto. Com base nos Captchas analisados durante o desenvolvimento do trabalho, verificamos que Captchas de áudio são menos complexos. Por exemplo, alguns destes são formados por sons sem ruído. Ou seja, uma tabela de sons e classificações seria suficiente para quebrar os Captchas. Nos casos com ruído, podemos utilizar duas técnicas para quebrar Captchas de áudio. A primeira é baseada em engenharia de características [ref], que extrai covariáveis dos áudios, para serem utilizados posteriormente em um modelo de regressão clássico. O segundo método consiste em calcular o espectrograma do áudio e tratá-lo como um Captcha de imagem. 3.1.2 Covariáveis e número de respostas variável Outra forma comum de manifestação de Captchas são imagens em que o número de letras varia. Esse problema é mais complexo que o anterior pois a variável resposta não é mais um vetor de tamanho \\(L\\) fixo. Assumindo que o número de letras máximo que aparece numa imagem é fixo, uma solução para o problema de tamanho variável é considerar um caractere adicional _ no alfabeto, chamado placeholder, que representa a ausência do caractere em determinada posição. Assim, uma imagem com \\(L_{\\max} = 5\\), por exemplo, poderia ter uma classificação cad5_, que tem apenas quatro letras. O problema dessa proposta é que a posição dos placeholders não importa na classificação do captcha. Ou seja, as soluções cad5_, ca_d5 e _cad5 são equivalentes. Isso torna o problema mais difícil de controlar. Outra alternativa para o problema é considerar que um de nossos interesses de predição é justamente o número de letras. Assim, teríamos \\[ \\tilde{\\mathbf{y}} = \\left[l \\;\\; \\mathbf y^\\top \\right]^\\top, \\] onde \\(l\\) é o número de letras do Captcha específico e \\(\\mathbf y\\) tem comprimento \\(L_{\\max}\\), preenchido com placeholders como anteriormente. A presença do número de letras como componente da variável resposta do problema permite trabalhar adequadamente com os placeholders, pois podemos descartá-los na função de perda (verossimilhança) nos casos em que o número de letras estimadas for menor que \\(L_{\\max}\\). Usualmente, o problema de Captchas de tamanho variável é acompanhado pelo problema das covariáveis. Um tipo comum de Captcha com covariáveis são questões como “digite todas as letras da cor verde”. Nesse caso, “verde” é uma covariável, pois é uma das informações que deve ser utilizada em conjunto com a imagem completa para predizr o texto do Captcha. Inicialmente, pode parecer contra intuitivo considerar uma imagem e um texto como covariáveis para predizer o valor de \\(\\mathbf y\\), mas isso se dá de forma natural, principalmente na solução que proposta no Capítulo @ref{results}. 3.1.3 reCaptcha "],
["solucao.html", "Capítulo 4 Solução 4.1 4.2 Formas de reduzir o tamanho da amostra", " Capítulo 4 Solução 4.1 (Ahn, Blum, and Langford 2002) define captchas pela primeira vez (Von Ahn et al. 2003) define um problema de resolver captcha como um problema de inteligência artificial. (Mori and Malik 2003) apresenta uma solução rudimentar para o problema a partir de cortes em imagens. O modelo final acerta somente 33% dos casos. (Yan and El Ahmad 2008a) criam um modelo de quebrar captcha baseado em diversas heurísticas. (Yan and El Ahmad 2008b) usability issues in CAPTCHA design (Golle 2008) utilizam SVM (Motoyama et al. 2010) estudam o aspecto economico dos recaptchas (Bursztein, Martin, and Mitchell 2011) testam varios modelos em 15 captchas diferentes (Bursztein et al. 2014) mostram um modelo de reinforcement Um problema de resolver o CAPTCHA diretamente é que a variável resposta \\(\\mathbf y\\) tem um número exponencial de combinações. Na formulação do capítulo anterior, nossa resposta é uma palavra de \\(L\\) caracteres, sendo que cada caractere \\(c_j\\) pode ter \\(|\\mathcal A|\\) valores. Nessa construção, o total de combinações é \\(|\\mathcal A|^L\\). Por exemplo, um CAPTCHA com \\(L=6\\) letras e \\(|\\mathcal A| = 36\\) possibilidades em cada letra (26 letras do alfabeto e 10 algarismos), possui um total de 2.176.782.336 (&gt; 2 bilhões) combinações. Modelar essas imagens diretamente através de uma única variável resposta categórica é inviável. Por isso, uma forma de resolver CAPTCHAs é separando o problema em duas tarefas: segmentar e classificar. A tarefa de segmentação consiste em receber uma imagem com várias letras e detectar pontos de corte, separando-a em várias imagens de uma letra. Já a classificação consiste em receber uma imagem com uma letra e identificar o caractere correspondente. Nesse caso, a resposta é reduzida para \\(|\\mathcal A|\\) categorias, que cresce linearmente e, portanto, tratável. [img-fluxo] A literatura mostra através de estudos empíricos que a tarefa de segmentar é mais difícil do que a tarefa de classificar (Bursztein et al. 2014). Isso acontece porque o problema de classificação de letras segmentadas é similar ao problema de reconhecimento de caracteres (Optical Character Recognition, OCR), que é amplamente estudado e pode ser considerado resolvido. A segmentação, no entanto, é um problema em aberto e faz parte da literatura de oclusão de objetos em visão computacional. Por esse motivo, os desenvolvedores de CAPTCHAs de imagens baseadas em texto têm explorado métodos de dificultar a segmentação. As principais formas são i) colar os caracteres e ii) adicionar linhas ligando os dígitos. Essas técnicas são combinadas com a adição de ruído e distorção de caracteres para compor a imagem final. Vamos usar como exemplo o CAPTCHA do Tribunal de Justiça de Minas Gerais (TJMG). Nesse caso, temos \\(L=4\\) e \\(|\\mathcal A|=10\\), apenas os dez algarismos. A Figura 4.1 mostra um exemplo do captcha do TJMG. Podemos notar a utilização de distorção de catacteres e adição de linhas ligando os dígitos como formas de evitar a resolução automática. Figura 4.1: CAPTCHA do TJMG. Nesse caso, é podemos resolver o problema da segmentação realizando cortes fixos na imagem. Podemos também limitar os eixos x, tirando os espaços vazios à esquerda e à direita e y, removendo espaços superiores e inferiores. Por último, transformamos a imagem em escala de cinza. O resultado dessas operações de pré-processamento estão na Figura 4.2. op &lt;- graphics::par(mar = rep(0, 4)) arq_captcha %&gt;% read_captcha() %&gt;% dplyr::first() %&gt;% with(x) %&gt;% magrittr::extract(-c(1:7, 34:dim(.)[1]), -c(1:06, 107:dim(.)[2]), TRUE) %&gt;% grDevices::as.raster() %&gt;% graphics::plot() abline(v = 20 * 1:4, col = &#39;red&#39;) abline(h = c(0, 26), col = &#39;blue&#39;) Figura 4.2: CAPTCHA do TJMG após segmentação. O resultado são cinco imagens de dimensões 26x20, associadas a cada caractere. O próximo passo é transformar o banco de dados num formato tratável por modelos tradicionais de regressão. Para isso, colocamos cada pixel em uma coluna da nossa base de dados. No caso do TJMG, cada CAPTCHA gera uma tabela de 5 linhas e 520 (26 * 20) colunas. A Tabela 4.1 mostra as primeiras seis colunas dessa base. arq_captcha %&gt;% read_captcha() %&gt;% dplyr::first() %&gt;% with(x) %&gt;% magrittr::extract(-c(1:7, 34:dim(.)[1]), -c(1:06, 107:dim(.)[2]), TRUE) %&gt;% tibble::as_tibble() %&gt;% tibble::rownames_to_column(&#39;y&#39;) %&gt;% tidyr::gather(x, value, -y) %&gt;% dplyr::mutate_at(dplyr::vars(x, y), dplyr::funs(readr::parse_number)) %&gt;% dplyr::mutate(letra = (x - 1) %/% 20 + 1, x = x - (letra - 1) * 20) %&gt;% dplyr::mutate_at(dplyr::vars(x, y), dplyr::funs(sprintf(&#39;%02d&#39;, .))) %&gt;% tidyr::unite(xy, x, y) %&gt;% tidyr::spread(xy, value, sep = &#39;&#39;) %&gt;% dplyr::mutate(y = c(&#39;7&#39;, &#39;3&#39;, &#39;2&#39;, &#39;4&#39;, &#39;6&#39;)) %&gt;% dplyr::select(y, dplyr::everything(), -letra) %&gt;% dplyr::select(1:7) %&gt;% dplyr::mutate_at(dplyr::vars(-y), dplyr::funs(round(., 3))) %&gt;% knitr::kable(caption = &quot;Base de dados montada a partir de imagem segmentada.&quot;) Tabela 4.1: Base de dados montada a partir de imagem segmentada. y xy01_01 xy01_02 xy01_03 xy01_04 xy01_05 xy01_06 7 0.769 0.769 0.769 0.769 0.769 0.773 3 0.005 0.141 0.316 0.430 0.356 0.319 2 0.846 0.851 0.830 0.796 0.800 0.842 4 0.886 0.886 0.890 0.890 0.890 0.890 6 0.925 0.925 0.929 0.929 0.929 0.933 Agora basta rodar o mesmo para toda a base de treino e rodar um modelo. Nesse exemplo, utilizamos uma base de 1500 CAPTCHAs classificados. O resultado após o pré-processamento é uma base com 7500 linhas e 520 colunas. Escolhemos manter 6000 linhas para treino e as 1500 restantes para teste. Utilizamos um modelo de florestas aleatórias para o exemplo (Breiman 2001). O resultado do modelo pode ser verificado na Tabela 4.2, que mostra os observados versus preditos na base de teste. O acerto foi de 99.6% em cada caractere. Assumindo que o erro não depende da posição do caractere no CAPTCHA, o acerto para a imagem completa é de aproximadamente 98%. Tabela 4.2: Tabela de acertos e erros. y 0 1 2 3 4 5 6 7 8 9 0 156 . . . . . . . . . 1 . 160 . . . . . . . . 2 . . 147 . . . . . . . 3 . . 1 140 . . . . . . 4 . 2 . . 150 . . . . . 5 . . . . . 153 . . . . 6 . . . . . . 143 . . . 7 . . . . . . . 152 . . 8 . . . 2 1 . . . 139 . 9 . . . . . . . . 1 153 O resultado para o TJMG é bastante satisfatório, mas não generaliza para outros CAPTCHAs. Tome por exemplo o CAPTCHA da Receita Federal (RFB) da Figura 4.3. Nesse caso, a posição dos caracteres muda significativamente de imagem para imagem, e assim fica difícil cortar em pedaços. Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal A mesma técnica aplicada ao CAPTCHA RFB apresentou acerto de 78.8% do caractere, o que equivale a apenas 23.8% de acerto para toda a imagem. Claro que seria possível melhorar o poder preditivo com ajustes nos hipeparâmetros do modelo, mas o problema essencial nesse caso está na qualidade segmentação, e não na classificação dos caracteres. Por isso, faz-se necessária uma abordagem que trata o problema completo, sem passar explicitamente pela fase de segmentação. Ao invés de cortar a imagem, vamos extrair detalhes da imagem completa automaticamente e utilizar essas características como variáveis preditoras num modelo de regressão. Chamaremos essa abordagem de deep learning. 4.2 Formas de reduzir o tamanho da amostra Ensemble Data augmentation / geradores Tesseract Feedback manual oráculo FALSE [1] &quot;setosa&quot; &quot;versicolor&quot; &quot;virginica&quot; FALSE [1] &quot;setosa&quot; &quot;versicolor&quot; &quot;virginica&quot; CAPTCHAs em áudio "],
["resultados.html", "Capítulo 5 Resultados", " Capítulo 5 Resultados "],
["consideracoes-finais.html", "Capítulo 6 Considerações finais", " Capítulo 6 Considerações finais "],
["references.html", "References", " References "],
["pacote-decryptr.html", "Capítulo 7 Pacote decryptr", " Capítulo 7 Pacote decryptr "],
["captchas-em-audio.html", "Capítulo 8 CAPTCHAs em áudio", " Capítulo 8 CAPTCHAs em áudio "]
]
