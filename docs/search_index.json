[
["index.html", "Quebrando CAPTCHAs Capítulo 1 Introduction", " Quebrando CAPTCHAs Julio Trecenti 18 de julho de 2018 Capítulo 1 Introduction "],
["introducao.html", "Capítulo 2 Introdução 2.1 Objetivos 2.2 Resultados esperados 2.3 Revisão bibliográfica", " Capítulo 2 Introdução CAPTCHAs (Completely Automated Public Turing test to tell Computers and Humans Apart) são desafios criados com soluções fáceis de obter por humanos, mas difíceis de obter por robôs. Os CAPTCHAs nasceram entre 2000 e 2002 nos laboratórios da universidade de Carnegie Mellon (Ahn, Blum, and Langford 2002), como uma tecnologia utilizada para evitar ataques spam. Ao longo dos anos, os CAPTCHAs tornaram-se comuns em diversas páginas da internet, podendo ser encontrados a partir de desafios de visão, audição, operações matemáticas, entre outros. Essa popularidade também trouxe iniciativas para resolver CAPTCHAs automaticamente, a partir de inputs humanos, heurísticas codificadas manualmente e até sistemas mais sofisticados de inteligência artificial. A disputa entre geradores e resolvedores gera debates profundos até os dias de hoje. Apesar da origem na criptografia e motivação prática, pode-se argumentar que CAPTCHAs representam um problema geral da inteligência artificial (George et al. 2017). Essencialmente, o CAPTCHA (baseado em imagens) é uma resposta natural para pergunta de pesquisa: que aspecto da visão humana não pode ser automatizado? Essa pergunta serve não só para criar novos CAPTCHAs mas também para orientar a pesquisa em visão computacional. Uma forma ad-hoc de responder à essa pergunta é criando desafios complexos. Por exemplo, elaborando tarefas de identificar textos dentro de imagens completamente distorcidas e cheias de ruído. No entanto, hoje somos perfeitamente capazes de resolver esse problema com altíssima taxa de acerto, muitas vezes mais altas que de humanos. Para isso, só precisamos de uma base de dados de treino suficientemente grande e modelos de aprendizado estatístico flexíveis, que chamamos de força-bruta. Discutiremos sobre isso no Capítulo 3. Talvez a resposta não esteja na dificuldade, mas no contexto. Ao mudar o ambiente que circunda a tarefa, mudamos a base de dados necessária para lidar com o problema. Como o levantamento de novas bases de dados de treino é custosa, essa estratégia torna a resolução por métodos de força-bruta inexequíveis. Esse racional foi a base da criação da versão dois do reCaptcha da Google, amplamente utilizada nos dias de hoje. O reCaptcha pode ser considerado o problema a ser batido nessa área. E de que forma podemos avançar na pesquisa? Nossa hipótese, que é o objeto principal dessa tese, é a de que é possível desenvolver técnicas para aumentar a eficiência e a capacidade de generalização dos modelos para resolver CAPTCHAs baseados em textos, aproveitando ao máximo o que existe de informação disponível no contexto de CAPTCHAs e visão computacional. Qualquer passo positivo nesse sentido é um novo avanço na pesquisa de resolução de CAPTCHAs e, consequentemente, em problemas mais profundos de inteligência artificial. A jornada a deste projeto de doutorado parte do problema geral dos CAPTCHAs e se encerra na apresentação e avaliação de diversas abordagens para aumentar a eficiência e a capacidade de generalização dos modelos. No caminho, faremos uma ponte entre modelos estatísticos usuais e modelos de redes neurais convolucionais, com o intuito de mostrar que essencialmente estamos apenas estendendo modelos, não abandonando a estatística clássica. Nesse primeiro produto de qualificação, definimos o problema geral dos CAPTCHAs e suas variantes. Em seguida, mostramos a solução clássica e a solução força-bruta para o problema, apresentando os resultados obtidos até o momento. Encerramos o trabalho apresentando informalmente com os conceitos de eficiência e generalização, apontando os próximos passos que a pesquisa deve seguir. 2.1 Objetivos O objetivo geral dessa tese é buscar formas eficientes e gerais de resolver CAPTCHAs de imagens baseados em textos. Os objetivos específicos são: Definir o problema do CAPTCHA e duas variações Mostrar uma solução força-bruta que funciona com alta taxa de acurácia Realizar uma ponte teórica entre regressão logística e redes neurais convolucionais Desenvolver uma ferramenta para resolver CAPTCHAs que seja útil e simples de utilizar. Discutir e testar diversas abordagens para aumentar eficiência e capacidade de generalização dos modelos. 2.2 Resultados esperados O projeto de doutorado já possui novos avanços relevantes nesses pontos: Implementação colaborativa do pacote decryptr na linguagem R para resolver CAPTCHAs Ponte teórica entre modelo de regressão logística e redes neurais convolucionais utilizando notação comum para estatísticos. Levantamento de lista curada de artigos sobre o tema. Resolução de diversos CAPTCHAs que nunca foram trabalhados no passado. Ao final do projeto, teremos mais esses novos avanços: Implementação das metodologias mais recentes de forma reprodutível Estudo e validação de abordagens para aumentar eficiência e generalização dos algoritmos Investigação do uso de aprendizado por reforço e aproveitamento do oráculo 2.3 Revisão bibliográfica A produção acadêmica sobre CAPTCHAs se agrupa em dois tópicos: geração e resolução. Os artigos de geração buscam as formas mais eficazes de criar tarefas difíceis para robôs e fáceis para humanos. Já os artigos de resolução tentam criar novos métodos para lidar com os CAPTCHAs mais comuns da internet. (Ahn, Blum, and Langford 2002) define captchas pela primeira vez. Von Ahn et al. (2003) deduz o problema de resolver CAPTCHA a partir de uma definição matemática genérica do problema da inteligência artificial. Mori and Malik (2003) apresentam uma solução rudimentar para o problema a partir de cortes em imagens. O modelo final acerta somente 33% dos casos. Yan and El Ahmad (2008a) criam um modelo de quebrar CAPTCHAs baseado em diversas heurísticas. Yan and El Ahmad (2008b) apresentam os principais problemas de utilização no desenvolvimento de CAPTCHAs concluindo, principalmente, que CAPTCHAs baseados em textos podem sim ser desafios complexos. Golle (2008) utilizam máquinas de vetor de suporte pela primeira vez. Motoyama et al. (2010) estudam o aspecto econômico dos reCaptchas, avaliando o impacto de sua utilização ampla em toda a internet. Bursztein, Martin, and Mitchell (2011) testam diversos modelos em 15 captchas diferentes e concluem que a melhor forma de criar CAPTCHAs complicados é colando as letras. Bursztein et al. (2014) mostram pela primeira vez um modelo um modelo de aprendizado por reforço, utilizando feedbacks humanos. George et al. (2017) desenvolvem um novo modelo capaz de quebrar CAPTCHAs a partir de pouquíssimos exemplos. CAPTCHAs em áudio "],
["problema.html", "Capítulo 3 Problema 3.1 Variantes", " Capítulo 3 Problema O problema do Captcha pode ser entendido como um problema de classificação de imagens. Especificamente, nosso interesse é criar uma função \\(g\\) que recebe uma imagem \\(\\mathbf X = \\{x_{nmr} \\in [0,1]\\}_{N\\times M \\times R}\\) e retorna um vetor de índices \\(\\mathbf y\\), sendo que cada índice \\(y_j\\) corresponde a um caractere \\(c_j\\), \\(j = 1, \\dots, L\\), onde \\(L\\) é o número de caracteres contidos na imagem. Chamaremos \\(L\\) de comprimento do Captcha. Podemos detalhar as afirmações anteriores em três itens, listados abaixo. Nossa variável explicativa, a imagem, é uma matriz \\(\\mathbf X = \\{x_{ijk}\\}_{N\\times M \\times R}\\), em que \\(N\\) é o número de linhas, \\(M\\) é o número de colunas e \\(R\\) é o número de cores, ou canais. O elemento \\(x_{nm\\cdot}\\) é denominado pixel. Um pixel representa a menor unidade possível da imagem. Em uma imagem colorida, por exemplo, temos \\(R=3\\). Nesse caso, um pixel é um vetor de três dimensões com valores entre zero e um, representando a intensidade de vermelho, verde e azul da coordenada \\(n,m\\) da imagem. Numa imagem em escala de cinza, temos \\(R=1\\) e o pixel, de uma dimensão, representa a intensidade do cinza (com 1=branco e 0=preto). O objeto \\(C \\in \\mathcal A^L\\) é um vetor de itens de um alfabeto \\(\\mathcal A\\) com tamanho \\(|\\mathcal A|\\), finito e conhecido. Esse alfabeto contém todos os possíveis caracteres que podem aparecer na imagem. Nossa resposta \\(\\mathbf y \\in \\mathbb \\{1, \\dots, |\\mathcal A|\\}^L\\) é um vetor de índices de tamanho fixo. Cada elemento de \\(\\mathbf y\\) representa um valor do alfabeto \\(\\mathcal A\\). A construção de uma função \\(g\\) capaz de mapear \\(\\mathbf y\\) a partir de uma nova imagem \\(\\mathbf X\\) depende de uma amostra de imagens \\(\\mathbf X_1, \\dots, \\mathbf X_S\\) corretamente classificadas por \\(\\mathbf y_1, \\dots, \\mathbf y_S\\). A tarefa é, portanto, obter uma estimativa \\(\\hat g\\) para a função \\(g\\) que minimiza \\[ L(\\hat g(\\mathbf X), \\mathbf y) = \\mathbb I(g(\\mathbf X) \\neq \\mathbf y) \\] em que \\(\\mathbb I\\) é a função indicadora. 3.1 Variantes 3.1.1 Áudio Captchas também ser encontrados na forma de áudio. Nesses casos, o usuário é condicionado a ouvir um áudio e transcrever seu conteúdo em um texto. Com base nos Captchas analisados durante o desenvolvimento do trabalho, verificamos que Captchas de áudio são menos complexos. Por exemplo, alguns destes são formados por sons sem ruído. Ou seja, uma tabela de sons e classificações seria suficiente para quebrar os Captchas. Nos casos com ruído, podemos utilizar duas técnicas para quebrar Captchas de áudio. A primeira é baseada em engenharia de características [ref], que extrai covariáveis dos áudios, para serem utilizadas posteriormente em um modelo de regressão clássico. O segundo método consiste em calcular o espectrograma do áudio e tratá-lo como um Captcha de imagem. 3.1.2 Covariáveis e número de respostas variável Outra forma comum de manifestação de Captchas são imagens em que o número de letras varia. Esse problema é mais complexo que o anterior pois a variável resposta não é mais um vetor de tamanho \\(L\\) fixo. Assumindo que o número de letras máximo que aparece numa imagem é fixo, uma solução para o problema de tamanho variável é considerar um caractere adicional _ no alfabeto, chamado placeholder, que representa a ausência do caractere em determinada posição. Assim, uma imagem com \\(L_{\\max} = 5\\), por exemplo, poderia ter uma classificação cad5_, que tem apenas quatro letras. O problema dessa proposta é que a posição dos placeholders não importa na classificação do captcha. Ou seja, as soluções cad5_, ca_d5 e _cad5 são equivalentes. Isso aumenta a dificuldade na estimação dos parâmetros por gerar mais ótimos locais. Outra alternativa para o problema é considerar que um de nossos interesses de predição é justamente o número de letras. Assim, teríamos \\[ \\tilde{\\mathbf{y}} = \\left[l \\;\\; \\mathbf y^\\top \\right]^\\top, \\] onde \\(l\\) é o número de letras do Captcha específico e \\(\\mathbf y\\) tem comprimento \\(L_{\\max}\\), preenchido com placeholders como anteriormente. A presença do número de letras como componente da variável resposta do problema permite trabalhar adequadamente com os placeholders, pois podemos descartá-los na função de perda (verossimilhança) nos casos em que o número de letras estimadas for menor que \\(L_{\\max}\\). Usualmente, o problema de Captchas de tamanho variável é acompanhado pelo problema das covariáveis. Um tipo comum de Captcha com covariáveis são questões como “digite todas as letras da cor verde”. Nesse caso, “verde” é uma covariável, pois é uma das informações que deve ser utilizada em conjunto com a imagem completa para predizr o texto do Captcha. Inicialmente, pode parecer contra intuitivo considerar uma imagem e um texto como covariáveis para predizer o valor de \\(\\mathbf y\\), mas isso se dá de forma natural, principalmente na solução que proposta no Capítulo @ref{results}. 3.1.3 reCaptcha "],
["solucao.html", "Capítulo 4 Solução 4.1 Segmentação e classificação 4.2 Força-bruta 4.3 Eficiência e generalização", " Capítulo 4 Solução 4.1 Segmentação e classificação Um problema de resolver o CAPTCHA diretamente é que a variável resposta \\(\\mathbf y\\) tem um número exponencial de combinações. Na formulação do capítulo anterior, nossa resposta é uma palavra de \\(L\\) caracteres, sendo que cada caractere \\(c_j\\) pode ter \\(|\\mathcal A|\\) valores. Nessa construção, o total de combinações é \\(|\\mathcal A|^L\\). Por exemplo, um CAPTCHA com \\(L=6\\) letras e \\(|\\mathcal A| = 36\\) possibilidades em cada letra (26 letras do alfabeto e 10 algarismos), possui um total de 2.176.782.336 (&gt; 2 bilhões) combinações. Modelar essas imagens diretamente através de uma única variável resposta categórica é inviável. Por isso, uma forma de resolver CAPTCHAs é separando o problema em duas tarefas: segmentar e classificar. A tarefa de segmentação consiste em receber uma imagem com várias letras e detectar pontos de corte, separando-a em várias imagens de uma letra. Já a classificação consiste em receber uma imagem com uma letra e identificar o caractere correspondente. Nesse caso, a resposta é reduzida para \\(|\\mathcal A|\\) categorias, que cresce linearmente e, portanto, tratável. [img-fluxo] A literatura mostra através de estudos empíricos que a tarefa de segmentar é mais difícil do que a tarefa de classificar (Bursztein et al. 2014). Isso acontece porque o problema de classificação de letras segmentadas é similar ao problema de reconhecimento de caracteres (Optical Character Recognition, OCR), que é amplamente estudado e pode ser considerado resolvido. A segmentação, no entanto, é um problema em aberto e faz parte da literatura de oclusão de objetos em visão computacional. Por esse motivo, os desenvolvedores de CAPTCHAs de imagens baseadas em texto têm explorado métodos de dificultar a segmentação. As principais formas são i) colar os caracteres e ii) adicionar linhas ligando os dígitos. Essas técnicas são combinadas com a adição de ruído e distorção de caracteres para compor a imagem final. Vamos usar como exemplo o CAPTCHA do Tribunal de Justiça de Minas Gerais (TJMG). Nesse caso, temos \\(L=4\\) e \\(|\\mathcal A|=10\\), apenas os dez algarismos. A Figura 4.1 mostra um exemplo do captcha do TJMG. Podemos notar a utilização de distorção de catacteres e adição de linhas ligando os dígitos como formas de evitar a resolução automática. Figura 4.1: CAPTCHA do TJMG. Nesse caso, podemos resolver o problema da segmentação realizando cortes fixos na imagem. Podemos também limitar os eixos x, tirando os espaços vazios à esquerda e à direita e y, removendo espaços superiores e inferiores. Por último, transformamos a imagem em escala de cinza. O resultado dessas operações de pré-processamento estão na Figura 4.2. op &lt;- graphics::par(mar = rep(0, 4)) arq_captcha %&gt;% read_captcha() %&gt;% dplyr::first() %&gt;% with(x) %&gt;% magrittr::extract(-c(1:7, 34:dim(.)[1]), -c(1:06, 107:dim(.)[2]), TRUE) %&gt;% grDevices::as.raster() %&gt;% graphics::plot() abline(v = 20 * 1:4, col = &#39;red&#39;) abline(h = c(0, 26), col = &#39;blue&#39;) Figura 4.2: CAPTCHA do TJMG após segmentação. O resultado são cinco imagens de dimensões 26x20, associadas a cada caractere. O próximo passo é transformar o banco de dados num formato tratável por modelos tradicionais de regressão. Para isso, colocamos cada pixel em uma coluna da nossa base de dados. No caso do TJMG, cada CAPTCHA gera uma tabela de 5 linhas e 520 (26 * 20) colunas. A Tabela 4.1 mostra as primeiras seis colunas dessa base. arq_captcha %&gt;% read_captcha() %&gt;% dplyr::first() %&gt;% with(x) %&gt;% magrittr::extract(-c(1:7, 34:dim(.)[1]), -c(1:06, 107:dim(.)[2]), TRUE) %&gt;% tibble::as_tibble() %&gt;% tibble::rownames_to_column(&#39;y&#39;) %&gt;% tidyr::gather(x, value, -y) %&gt;% dplyr::mutate_at(dplyr::vars(x, y), dplyr::funs(readr::parse_number)) %&gt;% dplyr::mutate(letra = (x - 1) %/% 20 + 1, x = x - (letra - 1) * 20) %&gt;% dplyr::mutate_at(dplyr::vars(x, y), dplyr::funs(sprintf(&#39;%02d&#39;, .))) %&gt;% tidyr::unite(xy, x, y) %&gt;% tidyr::spread(xy, value, sep = &#39;&#39;) %&gt;% dplyr::mutate(y = c(&#39;7&#39;, &#39;3&#39;, &#39;2&#39;, &#39;4&#39;, &#39;6&#39;)) %&gt;% dplyr::select(y, dplyr::everything(), -letra) %&gt;% dplyr::select(1:7) %&gt;% dplyr::mutate_at(dplyr::vars(-y), dplyr::funs(round(., 3))) %&gt;% knitr::kable(caption = &quot;Base de dados montada a partir de imagem segmentada.&quot;) Tabela 4.1: Base de dados montada a partir de imagem segmentada. y xy01_01 xy01_02 xy01_03 xy01_04 xy01_05 xy01_06 7 0.769 0.769 0.769 0.769 0.769 0.773 3 0.005 0.141 0.316 0.430 0.356 0.319 2 0.846 0.851 0.830 0.796 0.800 0.842 4 0.886 0.886 0.890 0.890 0.890 0.890 6 0.925 0.925 0.929 0.929 0.929 0.933 Agora basta rodar o mesmo para toda a base de treino e rodar um modelo. Nesse exemplo, utilizamos uma base de 1500 CAPTCHAs classificados. O resultado após o pré-processamento é uma base com 7500 linhas e 520 colunas. Escolhemos manter 6000 linhas para treino e as 1500 restantes para teste. Utilizamos um modelo de florestas aleatórias para o exemplo (Breiman 2001). O resultado do modelo pode ser verificado na Tabela ??, que mostra os observados versus preditos na base de teste. O acerto foi de 99.6% em cada caractere. Assumindo que o erro não depende da posição do caractere no CAPTCHA, o acerto para a imagem completa é de aproximadamente 98%. O resultado para o TJMG é bastante satisfatório, mas não generaliza para outros CAPTCHAs. Tome por exemplo o CAPTCHA da Receita Federal (RFB) da Figura 4.3. Nesse caso, a posição dos caracteres muda significativamente de imagem para imagem, e assim fica difícil cortar em pedaços. Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal Figura 4.3: CAPTCHA Receita Federal A mesma técnica aplicada ao CAPTCHA RFB apresentou acerto de 78.8% do caractere, o que equivale a apenas 23.8% de acerto para toda a imagem. Claro que seria possível melhorar o poder preditivo com ajustes nos hipeparâmetros do modelo, mas o problema essencial nesse caso está na qualidade segmentação, e não na classificação dos caracteres. Outro problema dessa técnica é que ela é incapaz de trabalhar com CAPTCHAs de comprimento variável. Nesse caso, seria necessário construir um modelo não supervisionado para identificar a posição das letras, o que adiciona um grau a mais de complexidade na resolução do CAPTCHA. Por isso, faz-se necessária uma abordagem que trabalha com problema completo, sem passar explicitamente pela fase de segmentação. Ao invés de cortar a imagem, vamos extrair detalhes da imagem completa automaticamente e utilizar essas características como variáveis preditoras num modelo de regressão. Chamaremos essa abordagem de força bruta. 4.2 Força-bruta A abordagem de força bruta utiliza redes neurais convolucionais. Para explicar o funcionamento dessa técnica, vamos primeiro apresentar definições para redes neurais e para a operação de convolução. Em seguida, vamos juntar os dois conceitos para construir o modelo utilizado nos CAPTCHAs. 4.2.1 Redes neurais Uma rede neural pode ser entendida como uma extensão de modelos lineares generalizados com a adição de uma arquitetura aos componentes do modelo. Para mostrar esse conceito, vamos partir da definição de um modelo regressão logística até construir uma rede neural com camadas ocultas. 4.2.1.1 Regressão logística O modelo linear generalizado é composto por três elementos: componente aleatório, componente sistemático e função de ligação. O componente aleatório é uma variável aleatória com distribuição pertencente à família exponencial, que dá origem à verossimilhança do modelo. O componente sistemático é uma combinação linear das variáveis preditoras com um vetor de parâmetros. A função de ligação é uma operação que leva a componente sistemática no valor esperado da componente aleatória. Uma forma comum de definir a ligação é propondo uma função com domínio nos números reais e contradomínio igual ao suporte do componente aleatório. Dessa forma, não é necessário impor restrições aos parâmetros da componente sistemática para que os valores ajustados variem na mesma faixa que o componente aletório. No exemplo da regressão logística, o componente aleatório tem distribuição Bernoulli com média \\(\\mu\\). O componente sistemático é a combinação linear \\(\\mathbf X \\boldsymbol \\beta\\) e a função de ligação é a inversa de \\[ g(\\mu) = \\log\\left(\\frac{\\mu}{1-\\mu}\\right) \\] A partir de uma amostra \\(y_1, \\dots, \\y_n\\) e observando que \\(\\mu_i = g^{-1}(\\mathbf X_i\\boldsymbol\\beta)\\), a verossimilhança do modelo é dada por \\[ \\mathcal L(\\boldsymbol \\beta|\\mathbf y) = \\prod_{i=1}^n f(y_i|\\boldsymbol\\beta) = \\prod_{i=1}^n\\mu_i^{y_i}(1-\\mu_i)^{1-y_i} \\] A log-verossimilhança é dada por \\[ l(\\boldsymbol \\beta|\\mathbf y) = \\sum_{i=1}^n y_i\\log(\\mu_i) + (1-y_i)\\log(1-\\mu_i) \\] Uma forma útil de olhar para a verossimilhança é a partir da função desvio, dada por \\[ D(\\mathbf y|\\boldsymbol \\beta) = l(\\mathbf y|\\mathbf y) - l(\\boldsymbol \\beta|\\mathbf y), \\] onde \\(l(\\mathbf y|\\mathbf y)\\) é a verossimilhança do modelo saturado, ou seja, calculada com \\(\\mathbf y\\) no lugar de \\(\\boldsymbol \\mu\\). A partir de um modelo ajustado, a função desvio pode ser interpretada como a distância entre a verossimilhança do modelo ajustado e a verossimilhança do modelo com um parâmetro para cada observação. Uma propriedade interessante da função desvio é que ela equivale à divergência de Kullback-Leibler [@…]. Por exemplo, para duas variáveis aleatórias com distribuição Bernoulli de parâmetros \\(p\\) e \\(q\\), respectivamente, a divergência de Kullback-Leibler é dada por \\[ D_{KL}(p||q) = p\\log\\left(\\frac p q\\right) + (1-p)\\log\\left(\\frac{1-p}{1-q}\\right) \\] É fácil ver que \\[ \\begin{align} D(\\mathbf y|{ \\boldsymbol \\beta}) &amp;= \\sum_{i=1}^n y_i\\log(y_i) + (1-y_i)\\log(1-y_i) - \\sum_{i=1}^n y_i\\log(\\mu_i) + (1-y_i)\\log(1-\\mu_i) \\\\ &amp;=\\sum_{i=1}^ny_i\\log\\left(\\frac{y_i}{\\mu_i}\\right) + (1-y_i)\\log\\left(\\frac{1-y_i}{1-\\mu_i}\\right) \\\\ &amp;= \\sum_{i=1}^n D_{KL}(y_i||\\mu_i) \\\\ &amp;= D_{KL}(\\mathbf y||{\\boldsymbol\\mu}). \\end{align} \\] Outra propriedade interessante é que o desvio identifica unicamente a verossimilhança do modelo. De fato, podemos reformular a definição do modelo linear generalizado a partir da especificação do desvio ou da divergência de Kullback-Leibler no lugar do componente aleatório. Essa propriedade será útil na comparação com redes neurais. Os estimadores de máxima verossimilhança de \\(\\boldsymbol \\beta\\) são os mesmos que minimizam a função desvio. Graças à concavidade da divergência de Kullback-Leibler [@…], Isso pode ser feito igualando os componentes do gradiente do desvio a zero e isolando os valores de \\(\\boldsymbol \\beta\\): \\[ \\nabla_{\\boldsymbol \\beta} D(\\mathbf y|{ \\boldsymbol \\beta}) = \\mathbf 0 \\] Como não é possível realizar essa operação analiticamente, utilizamos métodos iterativos. Existem dois principais métodos iterativos concorrentes: a descida de gradiente [@…] e o método de Newton-Raphson [@…]. No paradigma de modelos lineares generalizados, o método de Newton-Raphson é mais comum pois i) ele utiliza a segunda derivada e converge mais rápido que o método da descida de gradiente, que utiliza somente a primeira e ii) é possível demonstrar que ele equivale à aplicação iterada de mínimos quadrados ponderados [@…], o que facilita significativamente a implementação da solução. No paradigma de redes neurais, a descida de gradiente é mais comum por conta das vantagens backpropagation, que veremos na próxima subseção. Em resumo, podemos concluir que Um modelo linear generalizado pode ser definido por três componentes: a divergência de Kullback-Leibler, o preditor linear e a função de ligação. A estimação dos parâmetros do modelo é realizada via descida de gradiente ou Newton-Raphson. Em seguida, veremos que a rede neural aparece quando utilizamos o componente sistemático e a função de ligação várias vezes. 4.2.1.2 Extensão para redes neurais Uma forma de estender o modelo linear generalizado é considerando que o resultado da função de ligação aplicada ao componente sistemático é uma nova covariável \\(z\\). Assim, temos \\[ \\begin{aligned} \\mathbf z &amp;= g^{-1}(\\mathbf X \\boldsymbol \\beta)\\\\ \\boldsymbol\\mu &amp;= g^{-1}(\\alpha_2\\mathbf 1 + \\beta_2 \\mathbf z) = g^{-1}([\\mathbf 1\\;\\mathbf z]\\boldsymbol\\beta_2), \\end{aligned} \\] em que \\(\\boldsymbol\\beta_2 = [\\alpha_2\\;\\beta_2]^{\\top}\\). Agora, podemos aumentar o número de covariáveis \\(\\mathbf z\\) para \\(k\\) covariáveis, de modo que \\[ \\begin{aligned} \\mathbf z_j &amp;= g^{-1}(\\mathbf X \\boldsymbol \\beta_1^j)\\\\ \\boldsymbol\\mu &amp;= g^{-1}(\\mathbf Z\\boldsymbol\\beta_2), \\end{aligned} \\] onde \\(\\mathbf Z = [\\mathbf 1\\;\\mathbf z_1\\;\\dots\\;\\mathbf z_k]\\). O modelo espeficiado dessa forma também é chamado de multilayer perceptron, ou MLP [@…]. Mesmo com essa mudança, função desvio permanece a mesma, já que construída a partir de \\(\\boldsymbol \\mu\\). A única diferença é que agora ela é uma função de \\(\\boldsymbol \\beta_1^j\\), \\(j=1,\\dots,k\\) e \\(\\beta_2\\). O ajuste do modelo é realizado da mesma forma: \\[ \\nabla_{\\{\\boldsymbol \\beta_1^1, \\dots,\\boldsymbol \\beta_1^k,\\boldsymbol \\beta_2\\}} D(\\mathbf y|{ \\boldsymbol \\beta_1^1, \\dots,\\boldsymbol \\beta_1^k,\\boldsymbol \\beta_2}) = \\mathbf 0 \\] A vantagem dessa extensão é que adicionamos não linearidade ao modelo. Isso nos permite modelar relações mais complexas entre as preditoras e a resposta, o que pode resultar em melhores predições. De fato, é possível demonstrar que uma rede neural com uma camada oculta pode estima qualquer função contínua entre \\(\\mathbf X\\) e \\(\\mathbf y\\) [@…]. A desvantagem é que a estimação via Newton-Raphson é complicada de calcular. É nesse momento que aparecem as vantagens da descida de gradiente. Primeiro, defina \\(\\boldsymbol \\beta = \\{\\boldsymbol \\beta_1^1, \\dots,\\boldsymbol \\beta_1^k,\\boldsymbol \\beta_2\\}\\). Utilizando a regra da cadeia, a derivada parcial da função desvio em relação a \\(\\beta_{1,l}^{j}\\) é dado por \\[ \\frac{\\partial D(\\mathbf y|\\boldsymbol\\beta)}{\\partial \\beta_{1,l}^{j}} = \\sum_{i=1}^n\\frac{\\partial D(\\mathbf y|\\boldsymbol\\beta)}{\\partial z_{j,i}} \\frac{\\partial z_{j,i}}{\\partial \\beta_{1,l}^{j}} . \\] As derivadas em relação aos elementos de \\(\\boldsymbol \\beta_2\\) ocorrem diretamente, como na especificação em apenas um nível. Todas essas derivadas são fáceis de calcular e têm forma analítica definida. A aplicação da regra da cadeia de forma iterada nesse contexto é chamada de backpropagation. 4.2.1.3 Sinônimos e generalizações A literatura de redes neurais costuma trocar o nome função de ligação por ativação. Isso ocorre por motivos históricos, já que as redes neurais foram inicialmente inspiradas na ativação de sinapses de neurônios. No contexto de redes neurais, o objetivo da função de ativação não é, necessariamente, modificar a faixa de variação do contradomínio, pois o resultado após a função pode ser uma nova covariável. Isso sugere a existência de certa liberdade na escolha de ativações. A única restrição é que a função de ativação deve ser não linear, pois, se fosse linear, a aplicação de várias camadas de funções resultaria numa única combinação linear. As ativações mais populares são aquelas que têm derivadas simples. Já a escolha do componente aleatório é substituída por uma função de perda. A natureza probabilística do modelo é considerada indiretamente através da função desvio, como vimos anteriormente. No entanto, ao invés de trabalhar com o desvio, os pesquisadores de redes neurais definem genericamente uma função de perda que mensura uma discrepância entre os valores observados e estimados. Uma escolha razoável de função de perda é a própria divergência de Kullback-Leibler, calculada com base no suporte da variável resposta, gerando a função desvio. No entanto, dependendo da aplicação, podemos escolher outras perdas, que podem gerar distribuições de probabilidades sem formato analítico específico. Por último, a aplicação de camadas de não-linearidades podem ser representadas através de um grafo direcionado acíclico. Essa representação é vantajosa por dois motivos. O primeiro é que a aplicação facilita a especificação e entendimento do modelo e seus parâmetros, que podem ficar com notação carregada na especificação por fórmulas matemáticas. A segunda é que é possível utilizar conhecimentos de teoria dos grafos para aumentar a eficiência dos algoritmos. Por exemplo, é possível aproveitar parte dos cálculos do backpropagation na obtenção das derivadas parciais da função de perda (???). Em resumo, podemos concluir que Uma rede neural é uma extensão de modelos lineares generalizados que aplica combinações lineares e funções de ligação de forma iterada. A estimação dos parâmetros é realizada por descida de gradiente, explorando as vantagens do backpropagation. Funções de ligação são chamadas de funções de ativação. A função desvio é substituída por funções de perda mais gerais. A aplicação iterada de operações pode ser representada por um grafo direcionado acíclico. Existem diversas formas de definir, desenhar e apresentar os conceitos básicos de redes neurais e a descida de gradiente. As melhores são apresentadas em blogs, vídeos e aplicativos, onde as operações são apresentadas de forma interativa. O racional apresentado nesse texto buscou mostrar a relação intrínseca entre a regressão logística e as redes neurais. 4.2.2 A operação de convolução Convolução em imagens é uma operação usada nas áreas de visão computacional e processamento de sinais. Ela é utilizada para detectar padrões e aplicar filtros em imagens. Na prática, o que ela faz é calcular um novo valor para um pixel na posição \\((i,j)\\) de uma imagem com base nos valores dos pixels da vizinhança. Uma forma esperta de fazer essa soma ponderada é criando uma matriz de pesos. Com ela, não é necessário procurar os pontos da vizinhança. Para cada ponto \\((i,j)\\), obtemos a matriz de vizinhança, multiplicamos pontualmente pela matriz de pesos e somamos os valores resultantes. Chamaremos essa matriz de pesos de kernel. Considere esse exemplo 3x3: kern_horizontal &lt;- rbind(c(-1,-1,-1), c( 0, 0, 0), c( 1, 1, 1)) kern_horizontal E considere a seguinte imagem: &quot;imgs/emoji3.png&quot; %&gt;% magick::image_read() %&gt;% plot() A imagem é construída a partir dessa matriz: emoji &lt;- decryptr:::load_image(&quot;imgs/emoji3.png&quot;)[,,1] round(emoji, 1)[1:10, 1:12] Tome por exemplo o ponto \\((i,j) = (12,16)\\). A vizinhança 3x3 em torno desse ponto é dada por emoji[12 + (-1):1, 16 + (-1):1] A operação de convolução é feita da seguinte forma: \\[ \\begin{aligned} p^{\\text{new}}_{12,16} &amp;= k_{1,1}p_{11,15} + k_{1,2}p_{11,16} + k_{1,3}p_{11,17} + \\\\ &amp;+ k_{2,1}p_{12,15} + k_{2,2}p_{12,16} + k_{2,3}p_{12,17} + \\\\ &amp;+ k_{3,1}p_{13,15} + k_{3,2}p_{13,16} + k_{3,3}p_{13,17} \\end{aligned} \\] sum(emoji[12 + (-1):1, 16 + (-1):1] * kern_horizontal) Esse é o valor a ser colocado no ponto \\((i,j)\\). Isso funciona em todos os pontos que não estão na borda da imagem. Existem duas formas de trabalhar com as bordas da imagem. A primeira é preenchendo as bordas com zeros, de forma a considerar apenas os pontos da imagem. A segunda é descartar os pontos da borda e retornar uma imagem menor, contendo somente os pixels em que foi possível aplicar todo o kernel. convolve &lt;- function(img, kern) { # monta a bordinha na imagem. A borda deve ter (tamanho kernel) / 2, # de tamanho, arredondando para baixo pad &lt;- floor(dim(kern)[1] / 2) img_pad &lt;- matrix(0, nrow = nrow(img) + 2 * pad, ncol = ncol(img) + 2 * pad) img_pad[pad + 1:nrow(img), pad + 1:ncol(img)] &lt;- img[,,1] # aplica a convolução nos pontos da imagem for (i in seq_len(nrow(img))) { for (j in seq_len(ncol(img))) { img[i, j, 1] &lt;- sum(img_pad[i + 0:(2 * pad), j + 0:(2 * pad)] * kern) } } img[,,2] &lt;- img[,,3] &lt;- img[,,1] img } No nosso caso, o resultado da convolução fica como na Figura ??. Essa matriz não foi escolhida por acaso. Ela serve para destacar padrões horizontais da imagem. Como a primeira linha é formada -1s e a última é formada por 1s, a matriz fica com valor alto se a parte de cima do pixel for preta e a parte de baixo for branca (grande * 1 + pequeno * (-1)). A parte destacada da imagem acabou sendo os olhos (pois temos maior concentração de pixels pretos ali), além das extremidades superior e inferior do rosto. &quot;imgs/emoji3.png&quot; %&gt;% decryptr:::load_image() %&gt;% convolve(kern_horizontal) %&gt;% magick::image_read() %&gt;% plot() Com esse kernel aqui (vertical), a parte destacada do rosto são as extremidades dos lados: kern_vertical &lt;- rbind(c(-1, 0, 1), c(-1, 0, 1), c(-1, 0, 1)) kern_vertical &quot;imgs/emoji3.png&quot; %&gt;% decryptr:::load_image() %&gt;% convolve(kern_vertical) %&gt;% magick::image_read() %&gt;% plot() 4.2.3 Aplicando nos captchas Não tem segredo! Basta reaplicar o que já vimos. Vou apenas introduzir uma nova função chamada add_bias(), que simplesmente adiciona uma constante numérica para a matriz. Isso pode auxiliar na visualização, pois controlamos melhor os valores que ficam dentro do intervalo [0,1]. Lá na frente você entenderá o porquê do “bias”. add_bias &lt;- function (x, b) x + b Esse é o resultado de adicionar o kernel vertical e bias de 0.6. arq &lt;- &quot;imgs/captcha41367a06c5a.png&quot; op &lt;- graphics::par(mar = rep(0, 4)) arq %&gt;% decryptr:::load_image() %&gt;% convolve(kern_vertical) %&gt;% add_bias(.6) %&gt;% magick::image_read() %&gt;% plot() Agora o kernel na horizontal. Note que identificamos padrões das linhas horizontais que tentam atrapalhar a visão das letras. op &lt;- graphics::par(mar = rep(0, 4)) arq %&gt;% decryptr:::load_image() %&gt;% convolve(kern_horizontal) %&gt;% add_bias(.6) %&gt;% magick::image_read() %&gt;% plot() Colocando um após o outro, temos um resultado bem esquisito: op &lt;- graphics::par(mar = rep(0, 4)) arq %&gt;% decryptr:::load_image() %&gt;% convolve(kern_horizontal) %&gt;% convolve(kern_vertical) %&gt;% add_bias(.5) %&gt;% magick::image_read() %&gt;% plot() Também vou introduzir uma função chamada relu() aqui. ReLu significa Restricted Linear Unit e é uma função bem simples que zera tudo aquilo que é negativo e mantém tudo aquilo que é positivo. Assim, temos: relu &lt;- function(x) (x + abs(x)) / 2 relu(-1) relu( 3) Para visualização, essa função não serve para muita coisa, pois já fazemos a substituição de valores negativos por zero. No entanto, podemos fazer combos com a aplicação de várias convoluções. O resultado dos combos não seria possível somente com somas e multiplicações. Na prática, isso significa que com a aplicação de convoluções, bias e ReLu, podemos montar operações não lineares para extrair componentes da imagem. Olhe o exemplo abaixo. Parece que consegui identificar bem as coisas que são inúteis na imagem. op &lt;- graphics::par(mar = rep(0, 4)) arq %&gt;% decryptr:::load_image() %&gt;% # primeira convolucao convolve(kern_horizontal) %&gt;% add_bias(-.25) %&gt;% relu() %&gt;% # segunda convolucao convolve(kern_vertical) %&gt;% add_bias(.1) %&gt;% magick::image_read() %&gt;% plot() Isso tudo nos leva a pensar: será que eu consigo pensar em kernels que me ajudem a identificar as letras de uma forma razoável? 4.2.4 Redes neurais convolucionais 4.3 Eficiência e generalização A modelagem via redes neurais convolucionais apresenta resultados satisfatórios, mas tem dois problemas: eficiência e generalização. O problema de eficiência está relacionado com o fato de que a quantidade de imagens classificadas necessária para obter bom poder preditivo é alta. A partir de nossos testes, identificamos que são necessários em torno de dez mil imagens classificadas para obter um modelo com taxa de acerto maior que 90%. Já o problema de generalização implica que um modelo ajustado para um tipo CAPTCHA não funciona para outro, ainda que esses tipos sejam muito similares. Na verdade, esses modelos sofrem do problema de aprender versus decorar (Zhang et al. 2016). Isso significa que pequenas modificações na imagem original, e.g. inclusão de ruído gaussiano na imagem, podem resultar em predições completamente diferentes. Os dois problemas não são independentes. Se criarmos um modelo que generaliza, é razoável afirmar que a quantidade de dados necessária para se obter bom poder preditivo numa nova imagem se reduz. A Tabela ?? mostra algumas possíveis abordagens para resolver esses problemas. Eficiência Generalização Feedback Ensemble Reciclagem Ruído Enriquecimento 4.3.1 Feedback 4.3.2 Reciclagem 4.3.3 Ensemble 4.3.4 Ensemble Data augmentation / geradores Tesseract Feedback manual oráculo CAPTCHAs em áudio "],
["resultados.html", "Capítulo 5 Resultados", " Capítulo 5 Resultados "],
["consideracoes-finais.html", "Capítulo 6 Considerações finais", " Capítulo 6 Considerações finais "],
["references.html", "References", " References "],
["pacote-decryptr.html", "Capítulo 7 Pacote decryptr", " Capítulo 7 Pacote decryptr "],
["captchas-em-audio.html", "Capítulo 8 CAPTCHAs em áudio", " Capítulo 8 CAPTCHAs em áudio "]
]
